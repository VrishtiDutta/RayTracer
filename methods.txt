Functions implemented:
-------------------------------------------------------------------------------
Main:	Creates and stores image generated by the RayTracer program

	A3: create a ray for each pixel on the camera with origin at camera
	and call rayTrace (recursive), from which a RGB color value is received
	and stored it in the image struct.
	
	A4: Grid anti-aliasing is done by creating nxn # of rays for each grid
	in the pixel. Grid is setup to be 4x4. rayTrace is called on each of
	these rays and average the colors accumulated by the number of rays.
 
 
rayTrace: Given a ray returns a color value at the intersection made by ray

	Calls findFirstHit with given ray to check if intersections exists for
	this ray. If so create another ray from light source to point of 
	intersection and call findFirstHit again with this new ray. If ray from
	intersection point and light source does not intersect with any other
	object, call rtShade and add the return value to the color struct for 
	point. Create a reflection ray and recursively call rayTrace. 
	Return the recursively accumulated color value.
	
	
findFirstHit: Returns lambda value, intersection point and normal at intersect
	
	Iterates through all objects in the object list and call the object's 
	intersection function given the ray.
	Returns lambda, intersection point and normal values of nearest object.

planeIntersect: return lambda, intersection point and normal if intersection exists

	Transform ray from world space to model space, check if it intersects with 
	model plane. If so calculate lambda, intersection point and normal. Transform
	intersection point and normal to to world space using the M2W transform matrix.
	
sphereIntersect: same as planeIntersect
	Transform ray to model space and check for intersection with model sphere.
	Calculate lambda and use it to calculate intersection point and normal 
	(normal is just the intersection point for unit sphere).
	Transform intersection point and normal from model to world space.

normalTransform:
	return the inverse transpose of given vector.

rtShade: Takes intersection point, normal and returns color(intensity) value
	calculates ambient, diffuse and specular components. Return the sum of 3
	components in color struct.
	
setupscene:
	Set up small yellow plane on 'ceiling' to represent area light.
	Set up 4x4 area light in for loop 
	

texture mapping:
  	using the a, b relative coordinates for the image that has to be mapped to,
  	texmap in utils returns the RGB values of the scenery 
		
